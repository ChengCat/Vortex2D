#version 450
#extension GL_ARB_separate_shader_objects : enable

layout (local_size_x_id = 1, local_size_y_id = 2) in;

layout(push_constant) uniform Consts
{
  int width;
  int height;
  int n;
}consts;

layout(binding = 0, r32f) uniform image2D LevelSet;

layout(std430, binding = 1) buffer Polygon
{
  vec2 points[];
}polygon;

// +1 if is left
float orientation(vec2 a, vec2 b, vec2 p)
{
     return sign((b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x));
}

float dist_to_segment(vec2 a, vec2 b, vec2 p)
{
    vec2 dir = b - a;
    float l = dot(dir, dir);

    float t = clamp(dot(p - a, dir) / l, 0.0, 1.0);
    vec2 proj = a + t * dir;
    return distance(p, proj);
}

const float udist_bias = 0.001;

void main(void)
{
    ivec2 pos = ivec2(gl_GlobalInvocationID);
    if (pos.x >= 0 && pos.y >= 0 && pos.x < consts.width && pos.y < consts.height)
    {
        float value = imageLoad(LevelSet, pos).x;
        for (int i = consts.n - 1, j = 0; j < consts.n; i = j++)
        {
            float dist = dist_to_segment(polygon.points[i], polygon.points[j], pos);
            if (abs(dist - abs(value)) < udist_bias)
            {
                value = max(-orientation(polygon.points[i], polygon.points[j], pos) * dist, value);
            }
            else if (dist < abs(value))
            {
                value = -orientation(polygon.points[i], polygon.points[j], pos) * dist;
            }
        }

        imageStore(LevelSet, pos, vec4(value, 0.0, 0.0, 0.0));
    }
}
